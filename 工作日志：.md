# 工作日志：


## 2019.09.13  周三

### 1. 网易云课堂斗鱼直播
* 视频采集
  * 图片采集，声音采集
* 摄像头切换
* 视频文件的写入
* 使用真机运行后查找沙盒下单文件方法：
  * window -> devices -> 选中 “真机” 设备 -> 找到应用并选中 -> 点击齿轮，右键下载
  * 找到上一步下载的文件 -> 右键，显示包内容，到此就可以看到该应用在沙盒中的缓冲数据
  * 截图如下：
  * ![MacDown logo](/Users/dinpay/Desktop/window下打开.png)
  * ![MacDown logo](/Users/dinpay/Desktop/显示包内容.png)
  * ![MacDown logo](/Users/dinpay/Desktop/沙盒缓存文件.png)
   
  
### 2. 简书：程序员如何成为自由职业者？
* 作者：foruok
* 众包平台：解放号、云沃客、码市、程序员客栈

### 3. 智付微信支付SDK封装 DPWXPaySDK
* appid 与 SecretKey 通过商户签约时提供免去客户端接口传入
  * 进件时候输入 appid 与 SecretKey
* SDK 内调起支付插件的时候将token与支付类型(微信支付：050)不需要加密处理
* 使用 SDK 的报错原因
  * demo 需要添加微信支付所依赖的一些框架：

![MacDown logo](/Users/dinpay/Desktop/屏幕快照 2017-09-13 下午12.01.42.png)

* 添加警告框提示
* github 创建日志仓库，使用Github托管自己本地的项目代码方式三（命令行方式: Terminal Line），<http://www.cnblogs.com/XYQ-208910/p/5829946.html>
* 网络加载视图的封装
* 协助安全组测试抓包

## 2017.09.14 周四

### 1. 微信支付 SDK 测试demo报错-[__NSArrayM enqueue:]: unrecognized selector sent to instance 0x1276b6b60解决方案：
* 在工程配置中的”Other Linker Flags”中加入”-Objc -all_load”
* 添加后报符号重复，是因为SDK与demo里用的网络框架是一套，删除其中一套即可

## 09.15
### 1.xib xin新建的默认开启了autoresize，这样会开启autolayout，这个空间被添加到父控件的时候会随着父控件的拉伸而拉伸，设置autoresizeMask为none时不会随着父控件的拉伸而拉伸

### 2.在awakeFromNib中获取的bounds不正确，需要到layoutSubViews中获取到正确的frame

### 3.无限轮播
* 1. 方案比较，选择UICollectionView
  * UIScrollView，可以做，需要考虑cell重用，较麻烦
  * 第三方，代码冗余，很多是自己项目中用不到的东西
  * UICollectionView，自动cell重用，简单
* 2. 开发流程：
  * 2.1.创建一个view，添加UICollectionView，并添加UIPageControl
  * 2.2 设置UICollectionView相关参数，并准备本地数据测试
  * 2.3 自定义UICollectionViewCell，里面添加一个UIImageView
  * 2.4 在UICollectionView代理方法中给UIPageControl设置当前的显示的page
  * 2.5 分别为UICollectionView滚动到最前面与最后面的时候设置下一个view
  * 2.6 添加定时器
* 3. 开发过程遇到的困难：
  * 3.1 本地图片数据无法显示，原因是自定义cell的imageView在UICollectionView中需要设置cell.imageView.image = [UIImage ...];不能设置cell.imageView = [UIImageView alloc...];
  * 3.2 UUICollectionViewCell距离顶部有一段空白距离大概20，要到父视图的控制器设置self.automaticallyAdjustsScrollViewInsets = NO，看 这个UIViewController的这个属性你就明白了，此属性默认为YES，这样UIViewController下如果只有一个 UIScollView或者其子类，那么会自动留出空白，让scollview滚动经过各种bar下面时能隐约看到内容。但是每个 UIViewController只能有唯一一个UIScollView或者其子类，如果超过一个，需要将此属性设置为NO,自己去控制留白以及坐标问 题。

## 2019.09.15  周五

### 1. 商家 APP 登录注册
* FMDB 数据库操作封装
* 国际化的封装
* 在 swift 中 使用 oc 第三方库，制作桥接文件的关键步骤：
  * 按照下图标注的1、2、3、4、5 步骤，当然最关键的是第5步，之前有博文说，在第5步填入桥接文件的路径，这样做是不对的，在第5步的时候，直接把桥接文件拖到那个白色的框里，一定是直接拖动过去，然后按Enter ,这样我们自定义的桥接文件就建好了，可以尽情地把需要导入的oc 头文件 import 进去了。
 ![MacDown logo](/Users/dinpay/Desktop/屏幕快照 2017-09-15 上午8.54.18.png)
 * 在桥接文件导入需要的第三方头文件的时候，注意点：
 
```
#ifndef MerchantAPP_bridging_Header_h
#define MerchantAPP_bridging_Header_h

// 不能在此处导入头文件，否则在swift中找不到

#endif /* MerchantAPP_bridging_Header_h */
// 头文件导入该下面
#import "FMDB.h"
```
* 图片无限轮播
  * UIScrollView delegate:
  
```
- (void)scrollViewDidScroll:(UIScrollView *)scrollView; //滚动事件方法，滚动过程中会一直循环执行（滚动中…）

- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView; // 开始拖拽事件方法

- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; // 拖拽操作完成事件方法

- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; // 即将停止滚动事件方法（拖拽松开后开始减速时执行）

- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; // 滚动停止事件方法（滚动过程中减速停止后执行）
 
- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view NS_AVAILABLE_IOS(3_2); // 开始缩放事件方法

- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2); // 缩放操作完成事件方法

- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView; // 返回缩放视图，注意只有实现这个代理方法才能进行缩放，此方法返回需要缩放的视图
 
```
* 关于上面列出的几个方法，我们有必要说一下它们的执行顺序：
  * a.如果我们拖动一个UIScrollView中的子控件移动的时候它的执行顺序如下：开始拖拽，滚动，滚动…，停止拖拽，将要停止滚动，滚动，滚动…，停止滚动。 “将要停止滚动，滚动，滚动…，停止滚动”部分有可能执行也有可能不执行，关键看你拖拽的停止的时候是突然停止还是有一段惯性让他继续执行（就好像刹车一样，如果是急刹车就没有后面的惯性滑动了，如果是慢慢踩刹车可能会有一段滑动距离）。但是不管怎么样滚动事件会一直执行，因此如果在这个事件中进行某种操作一定要注意性能。
  * b.如果我们缩放UIScrollView的子控件的时候它的执行顺序如下：开始缩放，滚动，滚动…，停止缩放。同样在这个过程中滚动事件会一直调用(当然如果缩放过程中手指有别的动作也可能会触发其他事件，这个大家可以自己体会一下)。 
  
* UIPageControl 分页控件此方法可以根据页数返回UIPageControl合适的大小

```
    CGSize size= [_pageControl sizeForNumberOfPages:_imageCount];
    _pageControl.bounds=CGRectMake(0, 0, size.width, size.height);
    _pageControl.center=CGPointMake(SCREEN_WIDTH/2, SCREEN_HEIGHT-100);
```
* ceil函数，向上取整：输出结果是2。ceil()方法是向上取整，取得不小于浮点数的最小整数，对于正数来说是舍弃浮点数部分并加1，对于复数来说就是舍弃浮点数部分.

```
float f = 1.5;
int a;
a = ceil(f);
NSLog("a = %d",a);
```
* 高斯函数，向下取整，输出结果是1。floor()方法是向下取整，类似于数学中的高斯函数 [].取得不大于浮点数的最大整数，对于正数来说是舍弃浮点数部分，对于复数来说，舍弃浮点数部分后再减1.

```
float f = 1.6;
int a;
a = floor(f);
NSLog("a = %d",a);
```
